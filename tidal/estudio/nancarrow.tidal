{-
Estudio de ideas Nancarrowescas sobre el ritmo
-}


-- Tempo en ciclos por segundo
-- Phi ciclos por segundo

setcps 0.61805


{- Canon mensural

Estructura de canon en que las voces siguen pulsos diferentes.

Para este estudio utilizo la función fast, que permite acelerar la velocidad
del ciclo de un patrón por el factor especificado. Esta aceleración es,
geométricamente, una dilatación o contracción del tiempo.
De manera similar se puede usar la funciónslow,
que es recíproca a la función fast. Es decir:

x :: Int
fast x = slow (1/x)

x :: Int
slow x = fast (1/x)
-}



d1 -- primera voz
  $ s "superpiano" -- instrumento
  <| n " 2 13 4 5 [7 13] 12" -- notas de temperamento justo
--  # vowel "u" -- formantes de la letra "u"

d3 -- segunda voz
  $ fast "<0.61805!8 1.61805!5 3.2361!3 1.61805!5>" -- phi^(-1), phi, 2*phi
--  $ every "2 3 5" (jux (fast 1.61805)) -- canal derecho doble de rápido cada 3
--  $ jux rev -- canal derecho con patrón invertido
  $ s "superpiano"
  <| n " 2 13 4 5 [7 13] 12"
  + n  "-24"  -- dos octavas abajo
--  # vowel "o"
  
d2 -- tercera voz
  $ fast 3.2361 -- factor de dilatación (2*phi)
  $ s "superpiano" <| n " 2 13 4 5 [7 13] 12"
--  + n "<17 23 29 31 31 39 31 29 31 31 29 23>"  -- traslación de altura
  # vowel "a"



hush -- silencio

----------

{-
Canon / Traslación

Identificando el ciclo con un compas 6/8.
Cada bloque incluye ambas voces.

-}

-- Enteros
d1
  $ stack [
    s "superpiano" + n "2 13 4 5 [7 13] 1", -- primera voz, 6 pulsos
    ((1/6) <~) $ s "superpiano" + n "2 13 4 5 [7 13] 1" -- trasladado un pulso
    ]
  # cps 0.6

d1
  $ stack [
    s "superpiano" + n "2 13 4 5 [7 13] 1",
    ((2/6) <~) $ s "superpiano" + n "2 13 4 5 [7 13] 1" --traslado de dos pulso
    ]
  # cps 0.5

-- Racionales
d1
  $ stack [
    s "superpiano" + n "2 13 4 5 [7 13] 1",
    ((5/18) <~) $ s "superpiano" + n "2 13 4 5 [7 13] 1"
    ]
  # cps 0.5

-- Irracional por el número de Euler "e"
d1
  $ stack [
    s "superpiano" + n "2 13 4 5 [7 13] 1",
    ((2.7182) <~) $ s "superpiano" + n "2 13 4 5 [7 13] 12"
    ]
  # cps 0.5



-- Dilatación por "pi"
d1
  $ stack [
    s "superpiano" <| n " 2 13 4 5 [7 13] 12"
    , fast 3.141592654 $ s "superpiano" <| n " 2 13 4 5 [7 13] 12"
    ]
  # cps 0.33


hush

--------------------------------------------------------------------------------

--Experimentos

-- Canon 3:4:5


d1
  $ stack [
    s "superpiano(17,33)"
      # n " <2 13 4 5 7 13 12 . 1 3 7 1 3 7 2 4 8>" + n "1 12 24",
    fast (3/4) $ s "superpiano(17,33)"
      # n " <2 13 4 5 7 13 12 . 1 3 7 1 3 7 2 4 8>" + n "1 12 24",
    fast (3/5) $ s "superpiano(17,33)"
      # n " <2 13 4 5 7 13 12 . 1 3 7 1 3 7 2 4 8>" + n "1 12 24"
    ]
  # cps 0.25 # room 0.6

d2
  $ every 7 (jux rev)
  $ chop 6
  $ s "fm:4" # speed "<0.5 0.75 . 0.5 1.25 1.5>" # gain 1.3

d3
  $ s "supersquare" + n "< -13 -10 -12 -8 >"


solo 2

d1
  $ fast "<0.75 1.5 6 3>"
  $ stack [
    s "superpiano" + n " <2 5 7 2 5 7 2 5 4 5 . 1 3 7 1 3 7 2 4 8>",
    s "superpiano" + n " <2 5 7 2 5 7 2 5 4 5 . 1 3 7 1 3 7 2 4 8>"
      + n "<4 5 6 7>"
    ]
  # cps 0.25 # room 0.6

unsolo 2

solo 1

hush

unsolo 1


-- Otra manera de crear un canon en Tidal es usando la función off
-- que reproduce el patrón con un desplazamiento y transformación

d1 $ n "c a g" # s "supermandolin" # legato 3

d1
  $ off (0.25) (|+ n 12)
  $ off 0.125 (|+ n 7)
  $ n "c a g"
  # s "supermandolin"
  # legato 3

-- Podemos ver el tipo de la función off
:t off

{-
Toma una patrón de tiempo (que puede ser sólo un valor), luego una función que
transforma patrones y finalmente un patrón. De ver esta descripción del tipo
podemos inducir parte de su comportamiento:

1. Crea una copia del patrón original, que es desplazada en el ciclo por los
  valores del patrón de tiempo.
2. A este patrón se le aplica la función en cuestión, que en este caso particular
  corresponde a la trasposición por una octava y un quinta respectivamente.

En la expresión (|+ n 12) podemos ver una característica de Haskell:
la función infija |+ es truncada a sólo uno de sus argumentos,
lo que crea a su vez una función de un patrón en otro.

Esta abstracciones de funciones es llamada "currying".
-}
