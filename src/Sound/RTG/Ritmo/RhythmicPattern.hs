{-# LANGUAGE InstanceSigs #-}
module Sound.RTG.Ritmo.RhythmicPattern where
{-|
Module      : RhythmicPattern
Description : Main data type and its API helper functions
Copyright   : (c) Xavier GÃ³ngora, 2023
License     : GPL-3
Maintainer  : ixbalanque@protonmail.ch
Stability   : experimental

Rhythmic patterns are wrapped patterns with aditional structure.
-}

import           Data.Group                     (Group, invert)
import           Data.List                      (group)
import qualified Sound.RTG.Ritmo.Pattern        as P
import           Sound.RTG.Ritmo.PerfectBalance (indicatorVector)

-- | This data type represents integers modulo 2
data Binary = Zero | One deriving Eq

instance Show Binary where
  show :: Binary -> String
  show Zero = show 0
  show One  = show 1

instance Semigroup Binary where
  (<>) :: Binary -> Binary -> Binary
  Zero <> One  = One
  One  <> Zero = One
  _    <> _    = Zero

instance Monoid Binary where
  mempty :: Binary
  mempty = Zero

instance Group Binary where
  invert :: Binary -> Binary
  invert  = id

-- | Onset patterns are represented by binary valued lists
-- so that group structure can de lifted.
type OnsetPattern = P.Pattern Binary

-- | Groupings of pattern onsets generated by the
-- mutual nearest-neighbor graph.
type Groupings a = [P.Pattern a]

type OnsetGroups = Groupings Binary

-- | Meter carries musical context information
-- related to a patterns underlying pulse.
type Meter = Int

-- | This data type encondes a rhythmic pattern along with
-- other structure related to rhythm perception.
data Rhythmic = Rhythm {
                        pttrn  :: OnsetPattern,
                        groups :: OnsetGroups,
                        meter  :: !Meter,
                        sign   :: Int
                       } deriving Eq

instance Show Rhythmic where
  show rhythm = show (pttrn rhythm)

instance Semigroup Rhythmic where
  (<>) :: Rhythmic -> Rhythmic -> Rhythmic
  (Rhythm pttrn1 groups1 meter1 sign1) <> (Rhythm pttrn2 groups2 meter2 sign2) =
    let orientation = signum sign1 * signum sign2
        -- mtr = if orientation == 1 then meter1 + meter2 else max meter1 meter2
        mtr = sign1 * meter1 + sign2 * meter2
        fit = if sign1 > 0 then take else drop
    in Rhythm {
      pttrn = fit mtr $ case orientation of
          1    -> pttrn1 ++ pttrn2
          (-1) -> zipWith (<>) pttrn1 pttrn2 ++ P.diff pttrn1 pttrn2
          0    -> error "A rhythmic pattern always has a non-null orientation",
      groups = groups1 ++ groups2,
      meter = mtr,
      sign = orientation
      }

instance Monoid Rhythmic where
  mempty :: Rhythmic
  mempty = toRhythm []

instance Group Rhythmic where
  invert :: Rhythmic -> Rhythmic
  invert (Rhythm pttrn groups meter sign) = Rhythm pttrn groups meter (- sign)

toRhythm :: P.Pattern P.Time -> Rhythmic
toRhythm xs =
  let p = if null xs then [] else toOnset (indicatorVector xs)
  in Rhythm {
             pttrn = p,
             groups = mutualNNG p,
             meter = length p,
             sign = 1
            }

toOnset :: Integral a => P.Pattern a -> OnsetPattern
toOnset = map (\n -> if (== 0) . (`mod` 2) $ n then Zero else One)

mutualNNG :: OnsetPattern -> OnsetGroups
mutualNNG xs = []

-- | Compute the Inter-Onset-Interval of an onset pattern
iois :: OnsetPattern -> [Int]
iois xs =
  let intervals = group $ drop 1 $ scanl (\acc x -> if x == One then x:acc else acc) [] $ startPosition xs
  in map length intervals


startPosition :: OnsetPattern -> OnsetPattern
startPosition [] = []
startPosition pttrn@(x:xs)
  | null (reduceEmpty pttrn) = []
  | x == Zero = startPosition $ P.rotateLeft 1 pttrn
  | otherwise = pttrn

reduceEmpty :: OnsetPattern -> OnsetPattern
reduceEmpty []           = []
reduceEmpty pttrn@(x:xs) = if x == Zero then reduceEmpty xs else pttrn

clave = toRhythm P.clave
rumba = toRhythm P.rumba
gahu = toRhythm P.gahu
shiko = toRhythm P.shiko
bossa = toRhythm P.bossa
soukous = toRhythm P.soukous
