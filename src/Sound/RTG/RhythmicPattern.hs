{-# LANGUAGE FlexibleInstances #-}
{-# LANGUAGE GeneralizedNewtypeDeriving #-}
{-# LANGUAGE LambdaCase #-}

-- |
-- Module      : RhythmicPattern
-- Description : Main rhythm data type and transformations
-- Copyright   : (c) Xavier Góngora, 2024
-- License     : GPL-3
-- Maintainer  : ixbalanque@protonmail.ch
-- Stability   : experimental
--
-- A 'RhythmicPattern' is a event list in a newtype wrapper.
-- Types with a 'Rhythmic' instance can be converted to a 'RhythmicPattern'.
module Sound.RTG.RhythmicPattern
  ( Rhythmic (..),
    Pattern (..),
    rhythm,
    liftR,
    liftR2,
    patternBalance,
    patternEvenness,
  )
where

import Data.Group (Group, invert)
import Sound.RTG.Event (Event, eventsToTimePattern, fixOnset, swapEvent)
import Sound.RTG.List (centerReflection, rotateLeft)
import Sound.RTG.PerfectBalance (balance, evenness)
import Sound.RTG.Polygon (equivNecklace)
import Sound.RTG.Zip (euclideanZip)

-- TODO: Avoid exposing the data constructor (helps decouple implementation).

-- | Rhythm wrapper to define a new custom instances for lists
newtype Pattern a = Pattern {getPattern :: [a]} deriving (Functor, Foldable)

instance (Monoid a, Eq a, Show a) => Show (Pattern a) where
  show rhythm =
    unlines $
      [ show $ getPattern rhythm,
        "Evennes = " ++ show (patternEvenness rhythm),
        "Balance = " ++ show (patternBalance rhythm)
      ]

patternEvenness :: (Monoid a, Eq a) => Pattern a -> Double
patternEvenness (Pattern xs) = evenness . eventsToTimePattern $ xs

patternBalance :: (Monoid a, Eq a) => Pattern a -> Double
patternBalance (Pattern xs) = balance . eventsToTimePattern $ xs

-- | Two rhythms are considerd equal if one is a rotation of the other.
instance (Ord a) => Eq (Pattern a) where
  Pattern xs == Pattern ys = xs `equivNecklace` ys

liftR :: ([a] -> [b]) -> (Pattern a -> Pattern b)
liftR f (Pattern r) = Pattern (f r)

liftR2 :: ([a] -> [b] -> [c]) -> (Pattern a -> Pattern b -> Pattern c)
liftR2 f (Pattern r1) (Pattern r2) = Pattern (f r1 r2)

-- | Two general posibilities for the applicative instances: ZipList or regular list
instance Applicative Pattern where
  pure xs = Pattern $ pure xs
  Pattern fs <*> Pattern xs = Pattern (zipWith ($) fs xs) -- test

-- TODO: DEFINIR MONADA... QUIZAS AÑADIR COMO ESTADO EL METER

-- TODO: Falta lograr propiedad de inversos.
-- Tal propiedad implicaría que dados dos ritmos cualesquiera r1 y r2
-- entonces existe x de forma que r1 <> x == r2 es True
instance (Semigroup a) => Semigroup (Pattern a) where
  Pattern pttrn1 <> Pattern pttrn2 = Pattern $ pttrn1 `euclideanZip` pttrn2

-- TODO: ¿Lista vacía, relación de equivalencia o lista infinita?
-- También podría set [mempty], requiriendo el contexto de Monoid.
-- Lo que tendría más sentido considerando que estamos modelanto ritmos.
-- Depende de la operación. Depende de la operación.
instance (Semigroup a) => Monoid (Pattern a) where
  mempty = Pattern []

-- NOTE: Cannot be a proper group unless there's a way to "cancel" events.
-- NOTE: With center reflexion we have the property (invert . invert) x == x
-- NOTE: Previous operation, fmap invert, would need a reduction operation
-- as different list sizes would produce a different inverse.
instance (Group a) => Group (Pattern a) where
  invert = liftR centerReflection

-- | The quitessential rhythmic pattern. A sequence (list) of events.
type RhythmicPattern = Pattern Event

-- | Clusters are groupings of pattern onsets generated by the
-- mutual nearest-neighbor graph (MNNG).
type OnsetClusters = [Pattern Event]

-- | Meter carries musical context information
-- related to a patterns underlying pulse.
type Meter = Int

-- | The interface for rhythmic pattern types.
-- It lifts instances to rhythmic patterns.
-- NOTE: I've removed the unneeded Group constraints
-- because Rhythmic Pattern group operations were used in all cases
-- but 'inv', which I've changed to use them.
-- TODO: Decide wether to extract the operations to the top level.
class Rhythmic a where
  -- | Minimal complete definition
  toRhythm :: a -> RhythmicPattern

  -- | Inverses
  --
  -- prop> x & inv x = mempty
  --
  -- prop> inv x & x = mempty
  reflex :: a -> RhythmicPattern
  reflex = invert . toRhythm

  -- | Default group operation
  (&) :: (Rhythmic b) => a -> b -> RhythmicPattern
  x & y = toRhythm x <> toRhythm y

  -- | Complement. Exchange Onsets and Rests (Onset and Rest).
  --
  -- prop> (x & co x) = toRhythm $ replicate (length x) Onset
  --
  -- prop> co (co x) = toRhythm x
  co :: a -> RhythmicPattern
  co x =
    let rhythm = toRhythm x
     in fmap swapEvent rhythm

  -- | Reverse. Play pattern backwards, different from Inverse.
  --
  -- prop> rev (rev x) = toRhythm x
  rev :: a -> RhythmicPattern
  rev x =
    let Pattern xs = toRhythm x
     in Pattern $ reverse xs

  -- | Sequence. Plays each pattern every other cycle.
  -- TODO: needs to account for cycle/cycle speed
  (|>) :: (Rhythmic b) => a -> b -> RhythmicPattern
  r1 |> r2 = Pattern $ rhythm r1 ++ rhythm r2

  -- | Add up / Superposition
  --
  -- prop> x <+> x = x
  --
  -- prop> x <+> co x = toRhythm $ replicate (length x) Onset
  (<+>) :: (Rhythmic b) => a -> b -> RhythmicPattern
  r1 <+> r2 = fixOnset <$> toRhythm r1 <*> toRhythm r2

  rotate :: Int -> a -> RhythmicPattern
  rotate n x = Pattern $ rotateLeft n $ rhythm x

-- TODO
--
-- ¿Paralellization of patterns? Would depend on a implementation of concurrent streams.
--
-- Interpolate. Continuous transformation of patterns.
-- (/\)
--
-- Diverge. Interpolate into complement.
-- (\/) = (/\) . co

infixr 5 &

infixr 5 |>

infixl 5 <+>

-- TODO: ¿can euclidean rhythm generate all rhythms?
-- Euclidean rhythms generalize isochronous rhythms and evenly spacing. This might be enough.
-- And in this way rhythm generation might be abstracted.
-- Check this ideas after reading Toussaint chapters 20 and 21

-- | Access the binary pattern underlying a rhythmic type
-- TODO: Include in Rhythmic typle class?
-- TODO: Change name... too much rhythm stuff.
rhythm :: (Rhythmic a) => a -> [Event]
rhythm = getPattern . toRhythm

instance Rhythmic RhythmicPattern where
  toRhythm = id

-- instance Integral a => Rhythmic [a] where
--   toRhythm = Rhythm . integralToOnset
