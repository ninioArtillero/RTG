{-# LANGUAGE FlexibleInstances #-}
{-# LANGUAGE GeneralizedNewtypeDeriving #-}
{-# LANGUAGE LambdaCase #-}

-- |
-- Module      : RhythmicPattern
-- Description : Main rhythm data type and transformations
-- Copyright   : (c) Xavier Góngora, 2024
-- License     : GPL-3
-- Maintainer  : ixbalanque@protonmail.ch
-- Stability   : experimental
--
-- A 'RhythmicPattern' is a event list in a newtype wrapper.
-- Types with a 'Rhythmic' instance can be converted to a 'RhythmicPattern'.
module Sound.RTG.RhythmicPattern (Rhythmic (..), Rhythm (..), rhythm, liftR, liftR2,
                                 rhythmBalance, rhythmEvenness) where

import Data.Group (Group, invert)
import Sound.RTG.Event (Event, eventsToTimePattern, fixOnset, swapEvent)
import Sound.RTG.List (rotateLeft, centerReflection)
import Sound.RTG.PerfectBalance (balance, evenness)
import Sound.RTG.Polygon (equivNecklace)
import Sound.RTG.Zip (euclideanZip)

-- TODO: Avoid exposing the data constructor (helps decouple implementation).

-- | Rhythm wrapper to define a new custom instances for lists
newtype Rhythm a = Rhythm {getRhythm :: [a]} deriving (Functor, Foldable)

instance (Monoid a, Eq a, Show a) => Show (Rhythm a) where
  show rhythm =
    unlines $
      [ show $ getRhythm rhythm,
        "Evennes = " ++ show (rhythmEvenness rhythm),
        "Balance = " ++ show (rhythmBalance rhythm)
      ]

rhythmEvenness :: (Monoid a, Eq a) => Rhythm a -> Double
rhythmEvenness (Rhythm xs) = evenness . eventsToTimePattern $ xs

rhythmBalance :: (Monoid a, Eq a) => Rhythm a -> Double
rhythmBalance (Rhythm xs) = balance . eventsToTimePattern $ xs

-- | Two rhythms are considerd equal if one is a rotation of the other.
instance (Ord a) => Eq (Rhythm a) where
  Rhythm xs == Rhythm ys = xs `equivNecklace` ys

liftR :: ([a] -> [b]) -> (Rhythm a -> Rhythm b)
liftR f (Rhythm r) = Rhythm (f r)

liftR2 :: ([a] -> [b] -> [c]) -> (Rhythm a -> Rhythm b -> Rhythm c)
liftR2 f (Rhythm r1) (Rhythm r2) = Rhythm (f r1 r2)

-- | Two general posibilities for the applicative instances: ZipList or regular list
instance Applicative Rhythm where
  pure xs = Rhythm $ pure xs
  Rhythm fs <*> Rhythm xs = Rhythm (zipWith ($) fs xs) -- test

-- TODO: DEFINIR MONADA... QUIZAS AÑADIR COMO ESTADO EL METER

-- TODO: Falta lograr propiedad de inversos.
-- Tal propiedad implicaría que dados dos ritmos cualesquiera r1 y r2
-- entonces existe x de forma que r1 <> x == r2 es True
instance (Semigroup a) => Semigroup (Rhythm a) where
  Rhythm pttrn1 <> Rhythm pttrn2 = Rhythm $ pttrn1 `euclideanZip` pttrn2

-- TODO: ¿Lista vacía, relación de equivalencia o lista infinita?
-- También podría set [mempty], requiriendo el contexto de Monoid.
-- Lo que tendría más sentido considerando que estamos modelanto ritmos.
-- Depende de la operación. Depende de la operación.
instance (Semigroup a) => Monoid (Rhythm a) where
  mempty = Rhythm []

-- NOTE: Cannot be a proper group unless there's a way to "cancel" events.
-- NOTE: With center reflexion we have the property (invert . invert) x == x
-- NOTE: Previous operation, fmap invert, would need a reduction operation
-- as different list sizes would produce a different inverse.
instance (Group a) => Group (Rhythm a) where
  invert = liftR centerReflection

type RhythmicPattern = Rhythm Event

-- | Clusters are groupings of pattern onsets generated by the
-- mutual nearest-neighbor graph (MNNG).
type OnsetClusters = [Rhythm Event]

-- | Meter carries musical context information
-- related to a patterns underlying pulse.
type Meter = Int

-- | The interface for rhythmic pattern types.
-- It lifts instances to rhythmic patterns.
-- NOTE: I've removed the unneeded Group constraints
-- because Rhythmic Pattern group operations were used in all cases
-- but 'inv', which I've changed to use them.
-- TODO: Decide wether to extract the operations to the top level.
class Rhythmic a where
  -- | Minimal complete definition
  toRhythm :: a -> RhythmicPattern

  -- | Inverses
  --
  -- prop> x & inv x = mempty
  --
  -- prop> inv x & x = mempty
  reflex :: a -> RhythmicPattern
  reflex = invert . toRhythm

  -- | Default group operation
  (&) :: (Rhythmic b) => a -> b -> RhythmicPattern
  x & y = toRhythm x <> toRhythm y

  -- | Complement. Exchange Onsets and Rests (Onset and Rest).
  --
  -- prop> (x & co x) = toRhythm $ replicate (length x) Onset
  --
  -- prop> co (co x) = toRhythm x
  co :: a -> RhythmicPattern
  co x =
    let rhythm = toRhythm x
     in fmap swapEvent rhythm

  -- | Reverse. Play pattern backwards, different from Inverse.
  --
  -- prop> rev (rev x) = toRhythm x
  rev :: a -> RhythmicPattern
  rev x =
    let Rhythm xs = toRhythm x
     in Rhythm $ reverse xs

  -- | Sequence. Plays each pattern every other cycle.
  -- TODO: needs to account for cycle/cycle speed
  (|>) :: (Rhythmic b) => a -> b -> RhythmicPattern
  r1 |> r2 = Rhythm $ rhythm r1 ++ rhythm r2

  -- | Add up / Superposition
  --
  -- prop> x <+> x = x
  --
  -- prop> x <+> co x = toRhythm $ replicate (length x) Onset
  (<+>) :: (Rhythmic b) => a -> b -> RhythmicPattern
  r1 <+> r2 = fixOnset <$> toRhythm r1 <*> toRhythm r2

  rotate :: Int -> a -> RhythmicPattern
  rotate n x = Rhythm $ rotateLeft n $ rhythm x

-- TODO
--
-- ¿Paralellization of patterns? Would depend on a implementation of concurrent streams.
--
-- Interpolate. Continuous transformation of patterns.
-- (/\)
--
-- Diverge. Interpolate into complement.
-- (\/) = (/\) . co

infixr 5 &

infixr 5 |>

infixl 5 <+>

-- TODO: ¿can euclidean rhythm generate all rhythms?
-- Euclidean rhythms generalize isochronous rhythms and evenly spacing. This might be enough.
-- And in this way rhythm generation might be abstracted.
-- Check this ideas after reading Toussaint chapters 20 and 21

-- | Access the binary pattern underlying a rhythmic type
-- TODO: Include in Rhythmic typle class?
-- TODO: Change name... too much rhythm stuff.
rhythm :: (Rhythmic a) => a -> [Event]
rhythm = getRhythm . toRhythm

instance Rhythmic RhythmicPattern where
  toRhythm = id

-- instance Integral a => Rhythmic [a] where
--   toRhythm = Rhythm . integralToOnset
