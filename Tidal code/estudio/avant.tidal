-- Funciones avanzadas de Tidal Cycles

-- Combinar patrones ------------------------------------------------------------

d1
  $ stack [ -- función para sobre poner ritmos en una misma pista
    sound "bd(3,8)", -- ritmo euclideano
    (0.5 <~) $ sound "cp", -- desplazar el evento a la mitad del ciclo
    every 2 (density 2) $ (0.25 <~) $ sound "arpy*2" -- cada 2 ciclos acelerar
    ]

-- En el siguiente ejemplo tenemos transformaciones al nivel del patron (d1).

d1
  $ every 3 (rev) $ every 4 (chop 4) -- modificaciones del patrón completo
  $ stack [
    sound "bd(3,8)",
    (0.5 <~) $ sound "cp",
    every 2 (density 2) $ (0.25 <~) $ sound "arpy*2" ]

-- Otro patrón con stack
d1
  $ every 4 (rev)
  $ stack [
    "[~ bd bd] sd*3 bd",
    "cp(7,12)" # gain (fast 3.5 $ (sine / 8) + 0.7),
    "<hh*8 hh*12>",
    "superpiano"
      + n "1 4 7 1 4 7 3"
      # bpf (fast 8 $ sine*800 + 1500) -- efectos globales: sobre toda la órbita
      # room 0.3 -- efectos globales: afectan a todo el canal
    ]

-- Bateria en una órbita
-- La función stack, embebida en la sintaxis de la mininotation

d1
  $ n "[0(5,8), 1*2, <2*8 2*16>, 3(10,16), ~*15 4/4, <5(2,7) 5 5(2,7)>]"
  # s "drum"


-- Nos podemos mover entre escalas temporales al interior del patrón
-- Cada ciclo (y evento en el mismo) se puede subdividar de manera ilimitada.
-- Podemos incluso sintetizar por "stutter"
d1
  $ slow "1 17"
  $ n "c*40 [d!3 e!2] f4*37 [g*34 [c5 a 4a] b] f4*34 f3*17"
  # s "superpiano"
  # squiz 1.5 # room 0.5
  # gain 0.87

-- Ritmos euclidianos -----------------------------------------------------------

d1 $ s "[bd(3,8), cp(2,8,1), hh(7,8), bass:1(7,16)]"

d1 $ s "[bd(5,8), cp(4,8), hh(7,8), bass:1(7,16)]"

d1 $ s "[bd(5,8,1), cp(1,8)?, hh(7,8), bass:1(8,16,1)]"


d1 $ s "{bd!4, hh*2 hh:1, bd hh*3 808:4}"


-- Canon utilizando la función off ----------------------------------------------
-- el primer argumento determina la traslación del patrón
-- el segundo argumento aplica una función al patrón trasladado

d1
  $ off "0.6 0.3 0.3" (# speed 5)
  $ s "cp(<3 5>,8,1)"

d2
  $ (0.3 <~) -- traslación de patrón
  $ s "<kick(5,8,2)!3 kick(7,16)>"
  # n "0 1 1 1 3"

d3
  $ off (1/4) (|+ 2)
  $ off (1/8) (|+ 7)
  $ s "supersquare(3,16,1)" # speed 2 # note "c5 b4" # room 0.4 # gain 0.8

d2 $ every 3 (fast 2) $ s "hh(7,8,3)"

solo 3

unsolo 3

hush


-- Definir macros (sintaxis Haskell) --------------------------------------------

fill e x = every e (fix (ply 3) (s x))

d1 $ fill 2 "hh" $ s "bd hh sn hh"


-- Callar de manera dramática ---------------------------------------------------

-- silence y panic funcionan de manera similar para sonido corto
d1 $ s "supercomparator" # note "d4"

d1 silence -- detiene la reproducción hasta el final del ciclo

panic -- corta el sonido de golpe

-- en el caso de un sonido que exede la longitud de ciclo,
-- silence toma mucho tiempo y panic parece un error

d1 $ trigger 1 $ s "supercomparator" # note "d4" # sustain "8" # attack "0.5"
  # hold "4" # release "3.5"

d1 silence

panic

-- Se puede usar un "control bus", utilizando ampbus y poniendo
-- un amprecv en cada órbita que se quiera callar.

-- Iniciar el bus
d1 $ ampbus 1 0.5

d2 $ trigger 1 $ s "supercomparator"
  # note "d4" # sustain "8" # attack "0.5" # hold "4" # release "3.5"
  # amprecv 1

-- Callar el bus
d1 $ ampbus 1 0.0
